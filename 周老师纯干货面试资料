网络 bio nio netty

网络 io
阻塞        tomcat-------
  弊端 创建线程-----》线程池          浪费时间在内核的管理上

kernel  mysql  redis hbase
-----------------
kernel内核（程序）-----------system call 系统调用  api-------kernel 程序
  man man-pages  socket（2）代表系统调用 里面有个参数 noblock
  
  tomcat----------read（fd：8）----------》kernel《------------------------C1
  如果socket是阻塞的 通过reed读取8，阻塞了  程序目的是通过read来取IO内容----------------------》sock noblock------------------
  》nio  缺点：1000client 每次循环调用 1000 次read（）--调用内核的次数少一些
  ---------------》select 系统调用----------先调用一次select系统调用返回有状态的read之后再根据返回的fd文件描述符，调用read进行读取-----
  缺点：nio--》多路复用  程序和内核之后传递的东西成本有点高
  epoll kernel 7--杂项  epoll-create返回一个epoll文件描述符 会在内核中创建一个区域，直接打通程序和内核（这个区域使用的mmap），里面会有
  一个红黑数和链表
  epoll—ctl 来一个client就调用一次epoll-ctl，传入文件描述符，epoll文件描述符等参数，会把连接描述符放入红黑树，并只传入一次
  epoll-wait 周期性的调用这个系统调用，就会从链表中获取，是否有数据，有数据就进行处理
  
  KaFKa---别人可存 ，也可以取的东西，速度快   收到的数据存到磁盘，数据一定是通过网络到kafka进程，到内核，然后写道磁盘，传统方式
                                              数据读取到内核，再从内核到kafka进程里，在通过网络io传出去 传统方式
                                              sendfile 传入输出（目标地址），输入（文件）
                                             服务器有32g，jvm -Xmx2g java是个进程  jvm在java进程里面扣出了2g空间来执行 on heap归jvm管
                                             offheap堆外分配 如果用它，1.速度更快，不用经过jvm 2.减少频繁的gc发生
                                     三个位置 onheap offheap 基于offheap使用mmap开闭的一个内核和用户共享的映射空间这个速度更快把数据落地磁盘
            redis
            磁盘寻址  毫秒级别
            磁盘io 百兆级别
            
            内存寻址 纳秒
            
            秒》毫秒》微秒》纳秒
            磁盘：顺序读写，随机读写
            
            全量扫描（文件大1g的时候，打开速度就很慢）慢是因为什么产生的？磁盘寻址，全量io慢
            数据库快，为什么快？ 首先数据库有datapage 数据页，每页是4k，读取到内存里面  类型就是代表的数据字节，宽度
            分治，类型限制，索引---------------》用b+在内存中存放索引的数据，然后快速定位到索引的位置，读取到内存中，快速定位到真实数据地址
            再读取到内存中，定位到这个数据
              数据量大的时候，一个人查询的时候，是不受太多影响了，但是高并发的时候就会变慢，因为磁盘寻址慢，磁盘io是有瓶颈的
               Redis就成功引入，速度更快，并且免费
               内存存取数据 而且是合适的数据  主要是key value ，value的类型是什么，string，set，list，map， 比如value没有类型，只能存
               字符串，那能不能代表千变万化的数据   如果数据是个数据，我想去下标为3的数据，这个就是要把全部数据取到客户端，然后计算
               如果有类型，就可以在直接调用方法，获取到下标3的数据，这就是实现了计算向数据移动，而不是数据向计算移动
               因为redis是单进程，所以修改一个值，客户端并发三次，但是redis是线性执行的，中间少了数据库当中的事务开启，这些资源消耗
               就是很干净的执行三次修改值
          
                                              
  
