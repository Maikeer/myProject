缓存，数据可以丢，强调的是极速
数据库：数据绝对不能丢 速度+持久化 掉电易失！！
redis-mysql----一定要主要不要开启reids和mysql的强一致性，这样会影响redis 的性能，所以当redis作为前置数据库，mysql作为后置数据库的时候，
redis和mysql的一致性，只能用一个队列来向mysql做一致性数据，不能影响redis性能
存储层
1.快照/副本
2.日志
rdb----时点性
1.阻塞
redis不对外提供服务
2.非阻塞
redis进程继续对外提供服务并将数据落地-----这样时点会混乱
fork+ copy on write的方式创建一个子进程  父进程对数据的修改，子进程看不到
命令触发的 save 前台阻塞--关机维护  bgsave fork创建子进程
配置文件中编写bgsave 的规则： save这个标识
也就是说RDB其实就是用的fork的系统调用来创建的子进程，这个创建速度很快，并且不会占有多大的内存，因为他拷贝的其实就是指针数据和子进程与物理内存
的地址印设关系，当父进程或者子进程发送改变的时候，其实使用的是copy on write的方式，只有在需要写入的时候，数据才会复制，从而使各个进程拥有各自
的拷贝。也就是说，资源的复制只有在需要写入的时候才进行，在此之前，只是以只读方式共享。这种技术使地址空间的页的拷贝被推迟到实际发生写入的时候。
 
 弊端
1.不支持拉链，只有一个dump。rdb，所以必须要运维人员定制定时策略，比如每天把数据拷贝另一个地方，改成相应的日期名

linux系统知识 
管道 |
ls -l /etc | more 
1.前一命令的输出作为后命令的输入
2.管道会触发创建子进程 也就是|左右两边都会启动一个进程
列如 echo $$ 会打印当前进程的id
echo $$ | more 打印的也是父进程的id 因为$$的优先级优先于 | 这个命令，也就是说是先去的进程id在根据|开的子进程
echo $BASHPID | more 这个输出的就是当前子进程的id
使用linux的时候---父子进程
父进程的数据子进程能否看得到？ 常规思想，进程是要做数据隔离的
进阶思想 父进程其实可以让子进程看到它的数据的，但是不能修改父进程数据的
linux中环境变量子进程的修改不会破坏父进程，父进程的修改也不会影响子进程--------》创建子进程的速度应该是什么程度，如果父进程是redis，他的内存
数据比如10G------1.速度2.内存空间够不够--------》fork()系统调用----效果是创建速度快，使用的空间相对是小的
fork实现方式
内存（物理内存）-----程序有个虚拟地址空间（假设是redis）有个隐射到物理内存的地址
假如a的虚拟地址是3但是他指向物理内存地址的8，值是x-----假如我redis还想再创建一个子进程，这个用得就是fork（copy on write），类似于只是拷贝了一个父进程的指针
但是前面的只是我们知道两个进程之间修改值之后相互是不知道的
那么这个时候就需要copy on write 写时复制 创建子进程的时候并不发生复制-----结果就是创建进程变快了，根据经验不可能子进程或者父进程把所有数据
都改了--修改的时候拷贝成本不大，玩的其实就是指针
./test.sh & 代表在子进程里面执行这个脚本
export 变量名（num）
pstree可以查看bash
