# 声明式事务讲解-27

需要四个advice  总共五个对象

AspectJAwareAdvisorAutoProxyCreator

advisor ------------》DefaultBeanFactoryPointcutAdvisor

methodIntercepter ----》 TransactionInterceptor----NameMatchTransactionAttributeSource设置关于事务的属性

 pointcut ----》AspectJExpressionPointcut-----实例化

从xml---------注解

loadBeanDefinition加载配置文件-----对象的属性--------对象之间的包含关系

advisor-----advice-----1.method 2. 表达式 3.

##### obtainFreshBeanFactory-----》

loadBeanDefinitions(beanFactory)------》AbstractXmlApplicationContext中的loadBeanDefinitions方法中进入-----》XmlBeanDefinitionReader的loadBeanDefinitions方法------最终进入doLoadBeanDefinitions(inputSource, encodedResource.getResource())方法逻辑处理的核心步骤

------------------------------》进入DefaultBeanDefinitionDocumentReader类的parseBeanDefinitions类对xml标签一行一行进行解析，

在configbeanndefinitionParser的parse方法中1.configureAutoProxyCreator(parserContext, element)方法会自动注册代理模式创建器，AspectJAwareAdvisorAutoProxyCreator 2.分别对POINTCUT ADVISOR  ASPECT的元素进行解析

在AbstractBeanDefinitionParser的parse方法中 解析tx标签以及子标签，tx:advice tx:attributes tx:method

```
调用子类重写的doParse方法进行解析
doParse(element, parserContext, builder);
```

##### invokeBeanFactoryPostProcessors(beanFactory)完成属性替换

##### registerBeanPostProcessors(beanFactory)创建AspectJAwareAdvisorAutoProxyCreator对象

##### finishBeanFactoryInitialization 创建上面的四个对象具体过程

1创建DefaultBeanFactoryPointcutAdvisor过程中，在注入属性的时候会对advice和pointcut（AspectJExpressionPointcut）进入创建并注入，BeanFactory是通过BeanFactoryAware来注入的

##### 2.创建TransactionInterceptor和NameMatchTransactionAttributeSource

在创建TransactionInterceptor过程中发现他实现了methodIntercepter ，他最终在实现方法调用的时候，用的也是MethodIntercepter ，而MethodIntercepter 实现了Advice，所以我们在自定义实现的可以直接实现MethodIntercepter，使用过程中可以当做是Advice

在创建TransactionInterceptor之后，需要填充属性 transactionManager和transactionAttributeSource而这个transactionAttributeSource对应具体类是NameMatchTransactionAttributeSource，这里就会对它进行创建，NameMatchTransactionAttributeSource这个对象就是保存配置文件中tx:method中对应的name （get*，checkout等）

#### 如果一个具体的实现子类实现了MethodIntercepter接口，那么就可以直接把当前实现子类当做Advice

#### 回归一波创建对象的五种方式

1.自定义BeanPostProcessor生成代理对象InstantiationAwareBeanPostProcessor

2.通过反射创建对象

3.通过factoryMethod创建对象

4.通过FactoryBean创建对象

5.通过supplier创建对象

#### 

![image-20210107210953037](D:\GitHub\myProject\spring-springboot源码学习\五期源码课总结\iamges\image-20210107210953037.png)

#### 

# 注解配置的声明式事务讲解-28

注解方式的自动创建器是InfrastructureAdvisorAutoProxyCreator

advisor ------------》xml中DefaultBeanFactoryPointcutAdvisor 注解是BeanFactoryTransactionAttributeSourceAdvisor

methodIntercepter ----》 TransactionInterceptor----NameMatchTransactionAttributeSource设置关于事务的属性

 pointcut ----》AspectJExpressionPointcut-----实例化

所有类增加@configration的都会被代理，具体方法是在enhanceConfigurationClasses里面最后会循环创建代理

```
// 判断当前BeanDefinition是否是一个配置类，并为BeanDefinition设置属性为lite或者full，此处设置属性值是为了后续进行调用
// 如果Configuration配置proxyBeanMethods代理为true则为full
// 如果加了@Bean、@Component、@ComponentScan、@Import、@ImportResource注解，则设置为lite
// 如果配置类上被@Order注解标注，则设置BeanDefinition的order属性值
```

为什么@configration要代理，有什么作用？

 应该是获取@Bean对象是都从这个代理对象中获取，从而转到父类beanFactory中获取，保证@bean对象是单列，

因为代理对象之后，才能保证配置类中有的@Bean注解方法中的创建的对象，能够保证是单列对象

![image-20210107232133835](D:\GitHub\myProject\spring-springboot源码学习\五期源码课总结\iamges\image-20210107232133835.png)

用这个场景来验证spring加@configuration注解的类都必须被代理：

 首先有一个问题；如果方法P在调用方法A，在不生成代理对象的时候，此时会创建两次Person对象？那么创建两次对象，即在spring里非单例对象，这样的话无法保证spring中配置类的属性单例原则。

 那么有没有一种可能，通过代理方法来管理person对象的创建，如果调用方法p()会交由代理去判断person对象是否已经被创建成功，如果是那么则交由代理对象的proxy.invokeSuper的方法调用父类

 去创建；如果没有则通过代理类$$BeanFactory.getBean的方法创建对象person，从而保证对象只被创建一次，即为单例。

## 任务1：把xml配置的方式准备对象的过程画一个流程图出来

下图是注解模式

![](D:\马士兵架构\myProject\spring-springboot源码学习\五期源码课总结\iamges\20200405163130414.png)

## 事务的处理

commit    rollback

传播特性：7种  事务方法嵌套事务方法的时候，如何使用事务

![](D:\马士兵架构\myProject\spring-springboot源码学习\五期源码课总结\iamges\4310644bc23189d9b09612f0b13bf83a.png)

required:如果有事务在运行，当前的方法就在该事务中运行，否则启动新的一个事务

required_new:当前的方法必须启动新的事务，并在它自己的事务内运行。如果有事务正在运行，应该将它挂起

supports:如果有事务在运行，当前方法在这个事务运行，否则它可以不运行在事务中

not_supports：当前的方法不应该运行在事务中。如果有事务运行，将它挂起

mandatory：当前的方法必须运行在事务内部，如果没有运行的事务，就抛出异常

never：当前方法不应该运行在事务中，如果有运行的事务，就将抛出

nested：如果有事务在运行，当前的方法就应该在这个事务的嵌套事务内运行，否则就启动一个新的事务，并在它自己的事务内运行。

### 如果外层方法中包含事务，那么内层方法是否需要支持当前事务：

### 支持外层事务：required，supports，mandatory

### 不支持外层事务：required_new，not_supports，never



## 如果自己设计一个事务系统的话，如何操作

1.创建或者获取一个基本的事务

2.执行事务操作的执行sql操作

​		-------》是否有异常-----》没有，事务正常执行，清除当前执行的sql信息（TransactionInfo）-----》commit事务--------》数据库事务

​										-----》有，事务异常执行，清除当前执行的sql信息（TransactionInfo）-------》恢复之前的事务信息-----》回滚事务-------------------》数据库事务

​								-----------》释放连接，关闭连接

TransactionAspectSupport类中commitTransactionAfterReturning等等方法就是对以下处理方式的具体实现



after		关闭事务  实际操作的前置或者后置

before      开启事务  实际操作的前置或者后置

afterReturning   正常执行，返回数据结果，在返回结果的时候进行正常提交

afterThrowing	异常执行，执行回滚操作

around   实际操作的前置或者后置

#### 上面的方式可以选择N多种不同方式来操作，那种方式最简单？ 

##### 正常提交选择around，异常回滚选择afterThrowing方式

整个事务处理过程中，包含了几个Advisor？

1.ExposeInvocationInterceptor -----》 为了方便这责任链的调用

2.DefaultBeanFactoryPointcutAdvisor -----》TransationInterceptor-------》找到invoke方法中的invokeWithinTransaction去查看具体的completeTransactionAfterThrowing，cleanupTransactionInfo/清除事务信息，恢复线程私有的老的事务信息，commitTransactionAfterReturning(txInfo);//成功后提交，会进行资源储量，连接释放，恢复挂起事务等操作

createTransactionIfNecessary 创建TransactionInfo



##### 准备事务处理相关对象：事务对象，连接器，事务信息，事务状态，事务属性

##### 执行

##### 回滚操作-----有-----是否有异常-----正常提交

#### 正常操作的时候是存在事务方法嵌套事务方法的，此时怎么处理？

##### 这个时候就是在  执行（外层事务方法）步骤里面继续嵌套上面的一套流程形成事务嵌套（内层事务方法）---》这个时候就应该由不同的传播特性来决定不同方法的事务应该如何获取



















