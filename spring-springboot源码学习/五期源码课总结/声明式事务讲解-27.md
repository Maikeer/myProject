# 声明式事务讲解-27

需要四个advice  总共五个对象

AspectJAwareAdvisorAutoProxyCreator

advisor ------------》DefaultBeanFactoryPointcutAdvisor

methodIntercepter ----》 TransactionInterceptor----NameMatchTransactionAttributeSource设置关于事务的属性

 pointcut ----》AspectJExpressionPointcut-----实例化

从xml---------注解

loadBeanDefinition加载配置文件-----对象的属性--------对象之间的包含关系

advisor-----advice-----1.method 2. 表达式 3.

##### obtainFreshBeanFactory-----》

loadBeanDefinitions(beanFactory)------》AbstractXmlApplicationContext中的loadBeanDefinitions方法中进入-----》XmlBeanDefinitionReader的loadBeanDefinitions方法------最终进入doLoadBeanDefinitions(inputSource, encodedResource.getResource())方法逻辑处理的核心步骤

------------------------------》进入DefaultBeanDefinitionDocumentReader类的parseBeanDefinitions类对xml标签一行一行进行解析，

在configbeanndefinitionParser的parse方法中1.configureAutoProxyCreator(parserContext, element)方法会自动注册代理模式创建器，AspectJAwareAdvisorAutoProxyCreator 2.分别对POINTCUT ADVISOR  ASPECT的元素进行解析

在AbstractBeanDefinitionParser的parse方法中 解析tx标签以及子标签，tx:advice tx:attributes tx:method

```
调用子类重写的doParse方法进行解析
doParse(element, parserContext, builder);
```

##### invokeBeanFactoryPostProcessors(beanFactory)完成属性替换

##### registerBeanPostProcessors(beanFactory)创建AspectJAwareAdvisorAutoProxyCreator对象

##### finishBeanFactoryInitialization 创建上面的四个对象具体过程

1创建DefaultBeanFactoryPointcutAdvisor过程中，在注入属性的时候会对advice和pointcut（AspectJExpressionPointcut）进入创建并注入，BeanFactory是通过BeanFactoryAware来注入的

##### 2.创建TransactionInterceptor和NameMatchTransactionAttributeSource

在创建TransactionInterceptor过程中发现他实现了methodIntercepter ，他最终在实现方法调用的时候，用的也是MethodIntercepter ，而MethodIntercepter 实现了Advice，所以我们在自定义实现的可以直接实现MethodIntercepter，使用过程中可以当做是Advice

在创建TransactionInterceptor之后，需要填充属性 transactionManager和transactionAttributeSource而这个transactionAttributeSource对应具体类是NameMatchTransactionAttributeSource，这里就会对它进行创建，NameMatchTransactionAttributeSource这个对象就是保存配置文件中tx:method中对应的name （get*，checkout等）

#### 如果一个具体的实现子类实现了MethodIntercepter接口，那么就可以直接把当前实现子类当做Advice

#### 回归一波创建对象的五种方式

1.自定义BeanPostProcessor生成代理对象InstantiationAwareBeanPostProcessor

2.通过反射创建对象

3.通过factoryMethod创建对象

4.通过FactoryBean创建对象

5.通过supplier创建对象

#### 

![image-20210107210953037](D:\GitHub\myProject\spring-springboot源码学习\五期源码课总结\iamges\image-20210107210953037.png)

#### 

# 注解配置的声明式事务讲解-28

注解方式的自动创建器是InfrastructureAdvisorAutoProxyCreator

advisor ------------》xml中DefaultBeanFactoryPointcutAdvisor 注解是BeanFactoryTransactionAttributeSourceAdvisor

methodIntercepter ----》 TransactionInterceptor----NameMatchTransactionAttributeSource设置关于事务的属性

 pointcut ----》AspectJExpressionPointcut-----实例化

所有类增加@configration的都会被代理，具体方法是在enhanceConfigurationClasses里面最后会循环创建代理

```
// 判断当前BeanDefinition是否是一个配置类，并为BeanDefinition设置属性为lite或者full，此处设置属性值是为了后续进行调用
// 如果Configuration配置proxyBeanMethods代理为true则为full
// 如果加了@Bean、@Component、@ComponentScan、@Import、@ImportResource注解，则设置为lite
// 如果配置类上被@Order注解标注，则设置BeanDefinition的order属性值
```

为什么@configration要代理，有什么作用？

 应该是获取@Bean对象是都从这个代理对象中获取，从而转到父类beanFactory中获取，保证@bean对象是单列，

因为代理对象之后，才能保证配置类中有的@Bean注解方法中的创建的对象，能够保证是单列对象

![image-20210107232133835](D:\GitHub\myProject\spring-springboot源码学习\五期源码课总结\iamges\image-20210107232133835.png)

用这个场景来验证spring加@configuration注解的类都必须被代理：

 首先有一个问题；如果方法P在调用方法A，在不生成代理对象的时候，此时会创建两次Person对象？那么创建两次对象，即在spring里非单例对象，这样的话无法保证spring中配置类的属性单例原则。

 那么有没有一种可能，通过代理方法来管理person对象的创建，如果调用方法p()会交由代理去判断person对象是否已经被创建成功，如果是那么则交由代理对象的proxy.invokeSuper的方法调用父类

 去创建；如果没有则通过代理类$$BeanFactory.getBean的方法创建对象person，从而保证对象只被创建一次，即为单例。



















