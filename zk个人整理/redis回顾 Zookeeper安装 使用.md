# redis回顾 Zookeeper讲解

redis  单实例的 内存 快  复制集群的 单点故障 靠HA sentinel解决 主从复制 数据不能绝对的实时同步

可能最终一致性也谈不上   集群模式 sharding分片

完成分布式协调很难  分布式锁  很难需要考虑 锁续约 setnx

zookeeper 实现分布式协调

 leader 主  写 只能发送在主上面

follower 从  读可以发生在主从上

1.leader肯定会挂  带来服务不可用  事实上zk集群及其高可用的  ---如果有一种方式可以快速的恢复出一个leader

zk有两种运行状态  1. 可用状态  2. 不可用状态   3，不可用恢复到可用状态应该越快越好  官方压测是200ms恢复leader

zookeeper是一个目录树结构---------------node可以存数据 1MB -------1，持久节点 2，临时节点（一个client连接zk就相当于有个session）3.持久节点和临时节点都支持序列

### 特征与保障

ZooKeeper非常快速且非常简单。但是，由于其目标是作为构建更复杂的服务（例如同步）的基础，因此它提供了一组保证。这些是：

- 顺序一致性-来自客户端的更新将按照其发送顺序进行应用。

- 原子性-更新成功或失败。没有部分结果。

- 单个系统映像-无论客户端连接到哪个服务器，客户端都将看到相同的服务视图。也就是说，即使客户端故障转移到具有相同会话的其他服务器，客户端也永远不会看到系统的较旧视图。

- 可靠性-应用更新后，此更新将一直持续到客户端覆盖更新为止。

- 及时性-确保系统的客户视图在特定时间范围内是最新的。也就是最终一致性的意思

  

### 安装 验证 简单实用

mkdir -p /var/tangjin/zk  递归创建文件夹

scp -r ./zookeeper-3.5.8/ 192.168.42.177:`pwd`  远程拷贝文件夹到另外的服务器上面

echo 3 > /var/tangjin/zk/myid  打印一个3 重定向输出到 myid文件中

修改hosts文件 位置在 /etc/hosts   profile 文件在 /etc/profile

zkServer.sh start-foreground  这个方式启动zk会在前台打印所有的日志信息

cZxid 事务id 0x（前32位只是0省略了)----->2（后32位)----->00000002 一个值代表4个二进制位  后32位（00000002 ）代表你的事务id，前32位代表你的leader的纪元你是第几个leader，每次新的leader都会+1

有一个场景：当我客户端连接到了zk集群上的一个节点上node02上了，但是node02突然下线了，这个时候我的客户端有偏移连接到node01上面，这个时候我之前建立的session还在不在？我是否需要重新建立连接？ 

**答案是不需要的，因为zk有个统一视图，所有的server端都会有这个session都能看得到**

每次启动一个客户端对zkserver端进行连接，建立session，它都会消耗一个事务id的cZxid 都会+1的

退出客户端也会消耗一个事务id

create -e 创建临时节点

create -s /abd/xxx "sdsaa" 这个时候zk就会 在xxx后面加上一截00000001进行创建，可以做到创建不同的路径，多线程下不会出现覆盖情况

1.统一配置管理  1m数据   2.分组管理 path结构  3.统一命名  sequetial 序列 4.同步 靠临时节点支撑

### zk的作用

1.分布式锁靠临时节点--------》锁依托一个父节点且具备-s序列 代表父节点下可以有多把锁-------》队列式事务的锁     这些都是需要客户端实现的

2.HA 选主

netstat -natp | egrep '(2888|3888)'  查看的node01的

![image-20200612172138445](D:\马士兵架构\zk\images\image-20200612172138445.png)

3888 选主投票的 2888 leader接受write请求的

下图说明任意一个节点都可以找到其他节点，并且传输数据

![image-20200612173249778](D:\马士兵架构\zk\images\image-20200612173249778.png)





































